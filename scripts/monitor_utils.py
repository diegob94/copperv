#!/usr/bin/env python3
from pathlib import Path
import re
import argparse
import sys
from datetime import datetime
import os
import subprocess as sp

def generate_dissassembly_file(diss,elf,objdump):
    diss = Path(diss)
    def run(cmd):
        print('generate_dissassembly_file:',cmd)
        return sp.run(cmd,capture_output=True,encoding="utf-8",shell=True,check=True).stdout
    def j_opt(sections):
        return ' '.join([f'-j {s}' for s in sections])
    inst_sections = ['.init', '.text']
    r = run(f'{objdump} -D -Mno-aliases {elf} {j_opt(inst_sections)}')
    all_sections = run(f'{objdump} -h {elf}').splitlines()
    start = next((i for i,line in enumerate(all_sections) if line.startswith('Sections:')),None)
    all_sections = [line.split()[1] for line in all_sections[start:] if re.search('^\s+\d',line)]
    non_inst_sections = [i for i in all_sections if not i in inst_sections]
    r += run(f'{objdump} -s {elf} {j_opt(non_inst_sections)}')
    diss.write_text(r)
    return diss

def generate_printer(name, width, entries):
    printer_template = """
function `STRING {name};
input [`{width}-1:0] arg;
begin
    case (arg)
{entries_str}
        default:
            {name} = "UNKNOWN";
    endcase
end
endfunction
    """.rstrip().strip('\n')
    entry_template = """
        {entry}:
            {name} = "{entry_name}";
    """.rstrip().strip('\n')
    entries_str = []
    for entry in entries:
        entries_str.append(entry_template.format(
            entry = entry['entry'],
            name = name,
            entry_name = entry['entry_name']
        ))
    entries_str = '\n'.join(entries_str)
    return printer_template.format(
        name = name,
        width = width,
        entries_str = entries_str
    )

def generate_monitor_code(header):
    header = Path(header)
    parse_this = [
        dict(name = 'state'),
        dict(name = 'inst_type'),
        dict(name = 'funct'),
        dict(name = 'pc_next_sel'),
        dict(name = 'alu_op'),
    ]
    for parse in parse_this:
        parse['regex'] = re.compile(f'({parse["name"].upper()}_(\w+))\s+(\d+)')
        parse['entries'] = []
        parse['gtkwave'] = []
    with header.open('r') as f:
        for line in f:
            for parse in parse_this:
                m = parse['regex'].search(line)
                if m:
                    entry = m[1]
                    entry_name = m[2]
                    value = m[3]
                    if entry_name == 'WIDTH':
                        parse['width'] = entry
                    else:
                        f = dict(entry = '`'+entry, entry_name = entry_name)
                        parse['entries'].append(f)
                        parse['gtkwave'].append(f'{value} {entry_name}')
                    break
    printer_header  = [f'// File generated by monitor_utils.py script {datetime.now()}']
    for parse in parse_this:
        printer_header.append(generate_printer(parse['name'],parse['width'],parse['entries']))
    monitor_code = dict(
        printers = printer_header,
        gtkwave = {parse['name']:parse['gtkwave'] for parse in parse_this}
    )
    return monitor_code

def generate_monitor_printer(monitor,rtl_header):
    monitor = Path(monitor)
    monitor_code = generate_monitor_code(rtl_header)
    monitor.write_text('\n\n'.join(monitor_code['printers']) + '\n')
    return monitor

def generate_gtkwave_filters(gtkwave_dir,rtl_header):
    gtkwave_dir = Path(gtkwave_dir)
    monitor_code = generate_monitor_code(rtl_header)
    out_files = []
    for name,gtkwave_filter in monitor_code['gtkwave'].items():
        path = (gtkwave_dir/name).with_suffix('.gtkwfilter')
        path.write_text('\n'.join(gtkwave_filter) + '\n')
        out_files.append(path)
    return out_files

if __name__=='__main__':
    header_params = dict(
        metavar='RTL_HEADER_PATH',
        type=Path,
        help='RTL header file input for monitor and gtkwave filter',
    )
    parser = argparse.ArgumentParser(description='Generate testbench')
    subparsers = parser.add_subparsers()
    parser_mon = subparsers.add_parser('monitor_header')
    parser_mon.add_argument('rtl_header',**header_params)
    parser_mon.add_argument('-o',dest='monitor',metavar='MONITOR_PATH',type=Path,help='Pretty print header file for monitor_cpu output',required=True)
    parser_mon.set_defaults(func=generate_monitor_printer)
    parser_gtkwf = subparsers.add_parser('gtkwave_filters')
    parser_gtkwf.add_argument('rtl_header',**header_params)
    parser_gtkwf.add_argument('-o',dest='gtkwave',metavar='GTKW_FILTER_DIR_PATH',type=Path,help='Gtkwave filters output directory',required=True)
    parser_gtkwf.set_defaults(func=generate_gtkwave_filters)
    parser_diss = subparsers.add_parser('dissassemble')
    parser_diss.add_argument('elf',metavar='ELF_PATH', type=Path, help='ELF file to dissassemble input')
    parser_diss.add_argument('-o',dest='diss',metavar='DISS_PATH', type=Path, help='Dissassembly file output',required=True)
    parser_diss.add_argument('-objdump',metavar='OBJDUMP_PATH',type=Path,help='Path to objdump',required=True)
    parser_diss.set_defaults(func=generate_dissassembly_file)
    ## do work
    args = parser.parse_args()
    if len(vars(args)) == 0:
        parser.print_usage()
        sys.exit(1)
    args_dict = dict(vars(args))
    args_dict.pop('func')
    args.func(**args_dict)

