#!/usr/bin/env python3
from pathlib import Path
import re
import argparse
import sys
from datetime import datetime
import pexpect
import os

def generated(path):
    print(f"Generated {path.resolve()}")

def generate_dissassembly_file(dis,obj,objdump):
    def run(cmd):
        print(cmd)
        return pexpect.run(cmd).decode("utf-8")
    def j_opt(sections):
        return ' '.join([f'-j {s}' for s in sections])
    inst_sections = ['.init', '.text']
    r = run(f'{objdump} -D -Mno-aliases {obj} {j_opt(inst_sections)}')
    all_sections = run(f'{objdump} -h {obj}').splitlines()
    start = next((i for i,line in enumerate(all_sections) if line.startswith('Sections:')),None)
    all_sections = [line.split()[1] for line in all_sections[start:] if re.search('^\s+\d',line)]
    non_inst_sections = [i for i in all_sections if not i in inst_sections]
    r += run(f'{objdump} -s {obj} {j_opt(non_inst_sections)}')
    dis.write_text(r)
    generated(dis)

def generate_printer(name, width, entries):
    printer_template = """
function `STRING {name};
input [`{width}-1:0] arg;
begin
    case (arg)
{entries_str}
        default:
            {name} = "UNKNOWN";
    endcase
end
endfunction
    """.rstrip().strip('\n')
    entry_template = """
        {entry}:
            {name} = "{entry_name}";
    """.rstrip().strip('\n')
    entries_str = []
    for entry in entries:
        entries_str.append(entry_template.format(
            entry = entry['entry'],
            name = name,
            entry_name = entry['entry_name']
        ))
    entries_str = '\n'.join(entries_str)
    return printer_template.format(
        name = name,
        width = width,
        entries_str = entries_str
    )

def generate_monitor_code(header):
    header = Path(header)
    parse_this = [
        dict(name = 'state'),
        dict(name = 'inst_type'),
        dict(name = 'funct'),
        dict(name = 'pc_next_sel'),
        dict(name = 'alu_op'),
    ]
    for parse in parse_this:
        parse['regex'] = re.compile(f'({parse["name"].upper()}_(\w+))\s+(\d+)')
        parse['entries'] = []
        parse['gtkwave'] = []
    with header.open('r') as f:
        for line in f:
            for parse in parse_this:
                m = parse['regex'].search(line)
                if m:
                    entry = m[1]
                    entry_name = m[2]
                    value = m[3]
                    if entry_name == 'WIDTH':
                        parse['width'] = entry
                    else:
                        f = dict(entry = '`'+entry, entry_name = entry_name)
                        parse['entries'].append(f)
                        parse['gtkwave'].append(f'{value} {entry_name}')
                    break
    printer_header  = [f'// File generated by monitor_utils.py script {datetime.now()}']
    for parse in parse_this:
        printer_header.append(generate_printer(parse['name'],parse['width'],parse['entries']))
    monitor_code = dict(
        printers = printer_header,
        gtkwave = {parse['name']:parse['gtkwave'] for parse in parse_this}
    )
    return monitor_code

def generate_monitor_printer(monitor,rtl_header):
    monitor = Path(monitor)
    monitor_code = generate_monitor_code(rtl_header)
    monitor.write_text('\n\n'.join(monitor_code['printers']) + '\n')
    generated(args.monitor)
    return monitor

def generate_gtkwave_filters(gtkwave_dir,rtl_header):
    gtkwave_dir = Path(gtkwave_dir)
    monitor_code = generate_monitor_code(rtl_header)
    out_files = []
    for name,gtkwave_filter in monitor_code['gtkwave'].items():
        path = (gtkwave_dir/name).with_suffix('.gtkwfilter')
        path.write_text('\n'.join(gtkwave_filter) + '\n')
        generated(path)
        out_files.append(path)
    return out_files

if __name__=='__main__':
    parser = argparse.ArgumentParser(description='Generate testbench')
    parser.add_argument('-header',   type=Path, help='RTL header file')
    parser.add_argument('-monitor',  type=Path, help='Pretty print header file for monitor_cpu output')
    parser.add_argument('-gtkwave',  type=Path, help='Gtkwave filters output directory')
    parser.add_argument('-elf',      type=Path, help='ELF file to dissassemble')
    parser.add_argument('-diss_file',type=Path, help='Dissassembly file output')
    args = parser.parse_args()
    if args.header is not None:
        if args.monitor is not None:
            generate_monitor_printer(args.monitor,args.header)
        if args.gtkwave is not None:
            generate_gtkwave_filters(args.gtkwave,args.header)
    if args.elf is not None:
        if args.diss_file is not None:
            generate_dissassembly_file(args.diss_file,args.elf,'riscv64-unknown-elf-objdump')

